""""
Here we implement a class for loading data.
"""
import numpy as np
from torch.utils.data import Dataset, DataLoader
from sklearn.model_selection import StratifiedShuffleSplit, GroupShuffleSplit
import os
import pickle
import torch
import matplotlib.pyplot as plt
import time
from scipy import ndimage
import random
from tqdm import tqdm
import cv2

np.random.seed(0)

# wavelength: #272
view_channels = [24, 51, 118]

view_channels_vnir = [50, 88, 151]
view_channels_swir = [24, 51, 118]
# view_channels = [155//3, 248//3, 514//3]

wavelength_vnir = [380.916
    , 381.556
    , 382.197
    , 382.837
    , 383.478
    , 384.118
    , 384.759
    , 385.399
    , 386.04
    , 386.68
    , 387.321
    , 387.961
    , 388.602
    , 389.242
    , 389.883
    , 390.523
    , 391.163
    , 391.804
    , 392.444
    , 393.085
    , 393.725
    , 394.366
    , 395.006
    , 395.647
    , 396.287
    , 396.928
    , 397.568
    , 398.209
    , 398.849
    , 399.49
    , 400.13
    , 400.771
    , 401.411
    , 402.052
    , 402.692
    , 403.333
    , 403.973
    , 404.614
    , 405.254
    , 405.895
    , 406.535
    , 407.176
    , 407.816
    , 408.457
    , 409.097
    , 409.738
    , 410.378
    , 411.018
    , 411.659
    , 412.299
    , 412.94
    , 413.58
    , 414.221
    , 414.861
    , 415.502
    , 416.142
    , 416.783
    , 417.423
    , 418.064
    , 418.704
    , 419.345
    , 419.985
    , 420.626
    , 421.266
    , 421.907
    , 422.547
    , 423.188
    , 423.828
    , 424.469
    , 425.109
    , 425.75
    , 426.39
    , 427.031
    , 427.671
    , 428.312
    , 428.952
    , 429.593
    , 430.233
    , 430.873
    , 431.514
    , 432.154
    , 432.795
    , 433.435
    , 434.076
    , 434.716
    , 435.357
    , 435.997
    , 436.638
    , 437.278
    , 437.919
    , 438.559
    , 439.2
    , 439.84
    , 440.481
    , 441.121
    , 441.762
    , 442.402
    , 443.043
    , 443.683
    , 444.324
    , 444.964
    , 445.605
    , 446.245
    , 446.886
    , 447.526
    , 448.167
    , 448.807
    , 449.448
    , 450.088
    , 450.728
    , 451.369
    , 452.009
    , 452.65
    , 453.29
    , 453.931
    , 454.571
    , 455.212
    , 455.852
    , 456.493
    , 457.133
    , 457.774
    , 458.414
    , 459.055
    , 459.695
    , 460.336
    , 460.976
    , 461.617
    , 462.257
    , 462.898
    , 463.538
    , 464.179
    , 464.819
    , 465.46
    , 466.1
    , 466.741
    , 467.381
    , 468.022
    , 468.662
    , 469.303
    , 469.943
    , 470.584
    , 471.224
    , 471.864
    , 472.505
    , 473.145
    , 473.786
    , 474.426
    , 475.067
    , 475.707
    , 476.348
    , 476.988
    , 477.629
    , 478.269
    , 478.91
    , 479.55
    , 480.191
    , 480.831
    , 481.472
    , 482.112
    , 482.753
    , 483.393
    , 484.034
    , 484.674
    , 485.315
    , 485.955
    , 486.596
    , 487.236
    , 487.877
    , 488.517
    , 489.158
    , 489.798
    , 490.439
    , 491.079
    , 491.719
    , 492.36
    , 493
    , 493.641
    , 494.281
    , 494.922
    , 495.562
    , 496.203
    , 496.843
    , 497.484
    , 498.124
    , 498.765
    , 499.405
    , 500.046
    , 500.686
    , 501.327
    , 501.967
    , 502.608
    , 503.248
    , 503.889
    , 504.529
    , 505.17
    , 505.81
    , 506.451
    , 507.091
    , 507.732
    , 508.372
    , 509.013
    , 509.653
    , 510.294
    , 510.934
    , 511.574
    , 512.215
    , 512.855
    , 513.496
    , 514.136
    , 514.777
    , 515.417
    , 516.058
    , 516.698
    , 517.339
    , 517.979
    , 518.62
    , 519.26
    , 519.901
    , 520.541
    , 521.182
    , 521.822
    , 522.463
    , 523.103
    , 523.744
    , 524.384
    , 525.025
    , 525.665
    , 526.306
    , 526.946
    , 527.587
    , 528.227
    , 528.868
    , 529.508
    , 530.149
    , 530.789
    , 531.429
    , 532.07
    , 532.71
    , 533.351
    , 533.991
    , 534.632
    , 535.272
    , 535.913
    , 536.553
    , 537.194
    , 537.834
    , 538.475
    , 539.115
    , 539.756
    , 540.396
    , 541.037
    , 541.677
    , 542.318
    , 542.958
    , 543.599
    , 544.239
    , 544.88
    , 545.52
    , 546.161
    , 546.801
    , 547.442
    , 548.082
    , 548.723
    , 549.363
    , 550.004
    , 550.644
    , 551.284
    , 551.925
    , 552.565
    , 553.206
    , 553.846
    , 554.487
    , 555.127
    , 555.768
    , 556.408
    , 557.049
    , 557.689
    , 558.33
    , 558.97
    , 559.611
    , 560.251
    , 560.892
    , 561.532
    , 562.173
    , 562.813
    , 563.454
    , 564.094
    , 564.735
    , 565.375
    , 566.016
    , 566.656
    , 567.297
    , 567.937
    , 568.578
    , 569.218
    , 569.859
    , 570.499
    , 571.139
    , 571.78
    , 572.42
    , 573.061
    , 573.701
    , 574.342
    , 574.982
    , 575.623
    , 576.263
    , 576.904
    , 577.544
    , 578.185
    , 578.825
    , 579.466
    , 580.106
    , 580.747
    , 581.387
    , 582.028
    , 582.668
    , 583.309
    , 583.949
    , 584.59
    , 585.23
    , 585.871
    , 586.511
    , 587.152
    , 587.792
    , 588.433
    , 589.073
    , 589.714
    , 590.354
    , 590.994
    , 591.635
    , 592.275
    , 592.916
    , 593.556
    , 594.197
    , 594.837
    , 595.478
    , 596.118
    , 596.759
    , 597.399
    , 598.04
    , 598.68
    , 599.321
    , 599.961
    , 600.602
    , 601.242
    , 601.883
    , 602.523
    , 603.164
    , 603.804
    , 604.445
    , 605.085
    , 605.726
    , 606.366
    , 607.007
    , 607.647
    , 608.288
    , 608.928
    , 609.569
    , 610.209
    , 610.849
    , 611.49
    , 612.13
    , 612.771
    , 613.411
    , 614.052
    , 614.692
    , 615.333
    , 615.973
    , 616.614
    , 617.254
    , 617.895
    , 618.535
    , 619.176
    , 619.816
    , 620.457
    , 621.097
    , 621.738
    , 622.378
    , 623.019
    , 623.659
    , 624.3
    , 624.94
    , 625.581
    , 626.221
    , 626.862
    , 627.502
    , 628.143
    , 628.783
    , 629.424
    , 630.064
    , 630.705
    , 631.345
    , 631.985
    , 632.626
    , 633.266
    , 633.907
    , 634.547
    , 635.188
    , 635.828
    , 636.469
    , 637.109
    , 637.75
    , 638.39
    , 639.031
    , 639.671
    , 640.312
    , 640.952
    , 641.593
    , 642.233
    , 642.874
    , 643.514
    , 644.155
    , 644.795
    , 645.436
    , 646.076
    , 646.717
    , 647.357
    , 647.998
    , 648.638
    , 649.279
    , 649.919
    , 650.56
    , 651.2
    , 651.84
    , 652.481
    , 653.121
    , 653.762
    , 654.402
    , 655.043
    , 655.683
    , 656.324
    , 656.964
    , 657.605
    , 658.245
    , 658.886
    , 659.526
    , 660.167
    , 660.807
    , 661.448
    , 662.088
    , 662.729
    , 663.369
    , 664.01
    , 664.65
    , 665.291
    , 665.931
    , 666.572
    , 667.212
    , 667.853
    , 668.493
    , 669.134
    , 669.774
    , 670.415
    , 671.055
    , 671.695
    , 672.336
    , 672.976
    , 673.617
    , 674.257
    , 674.898
    , 675.538
    , 676.179
    , 676.819
    , 677.46
    , 678.1
    , 678.741
    , 679.381
    , 680.022
    , 680.662
    , 681.303
    , 681.943
    , 682.584
    , 683.224
    , 683.865
    , 684.505
    , 685.146
    , 685.786
    , 686.427
    , 687.067
    , 687.708
    , 688.348
    , 688.989
    , 689.629
    , 690.27
    , 690.91
    , 691.55
    , 692.191
    , 692.831
    , 693.472
    , 694.112
    , 694.753
    , 695.393
    , 696.034
    , 696.674
    , 697.315
    , 697.955
    , 698.596
    , 699.236
    , 699.877
    , 700.517
    , 701.158
    , 701.798
    , 702.439
    , 703.079
    , 703.72
    , 704.36
    , 705.001
    , 705.641
    , 706.282
    , 706.922
    , 707.563
    , 708.203
    , 708.844
    , 709.484
    , 710.125
    , 710.765
    , 711.405
    , 712.046
    , 712.686
    , 713.327
    , 713.967
    , 714.608
    , 715.248
    , 715.889
    , 716.529
    , 717.17
    , 717.81
    , 718.451
    , 719.091
    , 719.732
    , 720.372
    , 721.013
    , 721.653
    , 722.294
    , 722.934
    , 723.575
    , 724.215
    , 724.856
    , 725.496
    , 726.137
    , 726.777
    , 727.418
    , 728.058
    , 728.699
    , 729.339
    , 729.98
    , 730.62
    , 731.26
    , 731.901
    , 732.541
    , 733.182
    , 733.822
    , 734.463
    , 735.103
    , 735.744
    , 736.384
    , 737.025
    , 737.665
    , 738.306
    , 738.946
    , 739.587
    , 740.227
    , 740.868
    , 741.508
    , 742.149
    , 742.789
    , 743.43
    , 744.07
    , 744.711
    , 745.351
    , 745.992
    , 746.632
    , 747.273
    , 747.913
    , 748.554
    , 749.194
    , 749.835
    , 750.475
    , 751.115
    , 751.756
    , 752.396
    , 753.037
    , 753.677
    , 754.318
    , 754.958
    , 755.599
    , 756.239
    , 756.88
    , 757.52
    , 758.161
    , 758.801
    , 759.442
    , 760.082
    , 760.723
    , 761.363
    , 762.004
    , 762.644
    , 763.285
    , 763.925
    , 764.566
    , 765.206
    , 765.847
    , 766.487
    , 767.128
    , 767.768
    , 768.409
    , 769.049
    , 769.69
    , 770.33
    , 770.97
    , 771.611
    , 772.251
    , 772.892
    , 773.532
    , 774.173
    , 774.813
    , 775.454
    , 776.094
    , 776.735
    , 777.375
    , 778.016
    , 778.656
    , 779.297
    , 779.937
    , 780.578
    , 781.218
    , 781.859
    , 782.499
    , 783.14
    , 783.78
    , 784.421
    , 785.061
    , 785.702
    , 786.342
    , 786.983
    , 787.623
    , 788.264
    , 788.904
    , 789.545
    , 790.185
    , 790.826
    , 791.466
    , 792.106
    , 792.747
    , 793.387
    , 794.028
    , 794.668
    , 795.309
    , 795.949
    , 796.59
    , 797.23
    , 797.871
    , 798.511
    , 799.152
    , 799.792
    , 800.433
    , 801.073
    , 801.714
    , 802.354
    , 802.995
    , 803.635
    , 804.276
    , 804.916
    , 805.557
    , 806.197
    , 806.838
    , 807.478
    , 808.119
    , 808.759
    , 809.4
    , 810.04
    , 810.681
    , 811.321
    , 811.961
    , 812.602
    , 813.242
    , 813.883
    , 814.523
    , 815.164
    , 815.804
    , 816.445
    , 817.085
    , 817.726
    , 818.366
    , 819.007
    , 819.647
    , 820.288
    , 820.928
    , 821.569
    , 822.209
    , 822.85
    , 823.49
    , 824.131
    , 824.771
    , 825.412
    , 826.052
    , 826.693
    , 827.333
    , 827.974
    , 828.614
    , 829.255
    , 829.895
    , 830.536
    , 831.176
    , 831.816
    , 832.457
    , 833.097
    , 833.738
    , 834.378
    , 835.019
    , 835.659
    , 836.3
    , 836.94
    , 837.581
    , 838.221
    , 838.862
    , 839.502
    , 840.143
    , 840.783
    , 841.424
    , 842.064
    , 842.705
    , 843.345
    , 843.986
    , 844.626
    , 845.267
    , 845.907
    , 846.548
    , 847.188
    , 847.829
    , 848.469
    , 849.11
    , 849.75
    , 850.391
    , 851.031
    , 851.671
    , 852.312
    , 852.952
    , 853.593
    , 854.233
    , 854.874
    , 855.514
    , 856.155
    , 856.795
    , 857.436
    , 858.076
    , 858.717
    , 859.357
    , 859.998
    , 860.638
    , 861.279
    , 861.919
    , 862.56
    , 863.2
    , 863.841
    , 864.481
    , 865.122
    , 865.762
    , 866.403
    , 867.043
    , 867.684
    , 868.324
    , 868.965
    , 869.605
    , 870.246
    , 870.886
    , 871.526
    , 872.167
    , 872.807
    , 873.448
    , 874.088
    , 874.729
    , 875.369
    , 876.01
    , 876.65
    , 877.291
    , 877.931
    , 878.572
    , 879.212
    , 879.853
    , 880.493
    , 881.134
    , 881.774
    , 882.415
    , 883.055
    , 883.696
    , 884.336
    , 884.977
    , 885.617
    , 886.258
    , 886.898
    , 887.539
    , 888.179
    , 888.82
    , 889.46
    , 890.101
    , 890.741
    , 891.381
    , 892.022
    , 892.662
    , 893.303
    , 893.943
    , 894.584
    , 895.224
    , 895.865
    , 896.505
    , 897.146
    , 897.786
    , 898.427
    , 899.067
    , 899.708
    , 900.348
    , 900.989
    , 901.629
    , 902.27
    , 902.91
    , 903.551
    , 904.191
    , 904.832
    , 905.472
    , 906.113
    , 906.753
    , 907.394
    , 908.034
    , 908.675
    , 909.315
    , 909.956
    , 910.596
    , 911.236
    , 911.877
    , 912.517
    , 913.158
    , 913.798
    , 914.439
    , 915.079
    , 915.72
    , 916.36
    , 917.001
    , 917.641
    , 918.282
    , 918.922
    , 919.563
    , 920.203
    , 920.844
    , 921.484
    , 922.125
    , 922.765
    , 923.406
    , 924.046
    , 924.687
    , 925.327
    , 925.968
    , 926.608
    , 927.249
    , 927.889
    , 928.53
    , 929.17
    , 929.811
    , 930.451
    , 931.091
    , 931.732
    , 932.372
    , 933.013
    , 933.653
    , 934.294
    , 934.934
    , 935.575
    , 936.215
    , 936.856
    , 937.496
    , 938.137
    , 938.777
    , 939.418
    , 940.058
    , 940.699
    , 941.339
    , 941.98
    , 942.62
    , 943.261
    , 943.901
    , 944.542
    , 945.182
    , 945.823
    , 946.463
    , 947.104
    , 947.744
    , 948.385
    , 949.025
    , 949.666
    , 950.306
    , 950.947
    , 951.587
    , 952.227
    , 952.868
    , 953.508
    , 954.149
    , 954.789
    , 955.43
    , 956.07
    , 956.711
    , 957.351
    , 957.992
    , 958.632
    , 959.273
    , 959.913
    , 960.554
    , 961.194
    , 961.835
    , 962.475
    , 963.116
    , 963.756
    , 964.397
    , 965.037
    , 965.678
    , 966.318
    , 966.959
    , 967.599
    , 968.24
    , 968.88
    , 969.521
    , 970.161
    , 970.802
    , 971.442
    , 972.082
    , 972.723
    , 973.363
    , 974.004
    , 974.644
    , 975.285
    , 975.925
    , 976.566
    , 977.206
    , 977.847
    , 978.487
    , 979.128
    , 979.768
    , 980.409
    , 981.049
    , 981.69
    , 982.33
    , 982.971
    , 983.611
    , 984.252
    , 984.892
    , 985.533
    , 986.173
    , 986.814
    , 987.454
    , 988.095
    , 988.735
    , 989.376
    , 990.016
    , 990.657
    , 991.297
    , 991.937
    , 992.578
    , 993.218
    , 993.859
    , 994.499
    , 995.14
    , 995.78
    , 996.421
    , 997.061
    , 997.702
    , 998.342
    , 998.983
    , 999.623
    , 1000.26
    , 1000.9
    , 1001.54
    , 1002.19
    , 1002.83
    , 1003.47
    , 1004.11
    , 1004.75
    , 1005.39
    , 1006.03
    , 1006.67
    , 1007.31
    , 1007.95
    , 1008.59
    , 1009.23
    , 1009.87
    , 1010.51]
wavelength_swir = [
    900.992
    , 906.896
    , 912.799
    , 918.703
    , 924.606
    , 930.51
    , 936.413
    , 942.316
    , 948.22
    , 954.123
    , 960.027
    , 965.93
    , 971.833
    , 977.737
    , 983.64
    , 989.544
    , 995.447
    , 1001.35
    , 1007.25
    , 1013.16
    , 1019.06
    , 1024.96
    , 1030.87
    , 1036.77
    , 1042.67
    , 1048.58
    , 1054.48
    , 1060.38
    , 1066.29
    , 1072.19
    , 1078.09
    , 1084
    , 1089.9
    , 1095.8
    , 1101.71
    , 1107.61
    , 1113.52
    , 1119.42
    , 1125.32
    , 1131.23
    , 1137.13
    , 1143.03
    , 1148.94
    , 1154.84
    , 1160.74
    , 1166.65
    , 1172.55
    , 1178.45
    , 1184.36
    , 1190.26
    , 1196.16
    , 1202.07
    , 1207.97
    , 1213.87
    , 1219.78
    , 1225.68
    , 1231.58
    , 1237.49
    , 1243.39
    , 1249.29
    , 1255.2
    , 1261.1
    , 1267
    , 1272.91
    , 1278.81
    , 1284.71
    , 1290.62
    , 1296.52
    , 1302.42
    , 1308.33
    , 1314.23
    , 1320.13
    , 1326.04
    , 1331.94
    , 1337.84
    , 1343.75
    , 1349.65
    , 1355.56
    , 1361.46
    , 1367.36
    , 1373.27
    , 1379.17
    , 1385.07
    , 1390.98
    , 1396.88
    , 1402.78
    , 1408.69
    , 1414.59
    , 1420.49
    , 1426.4
    , 1432.3
    , 1438.2
    , 1444.11
    , 1450.01
    , 1455.91
    , 1461.82
    , 1467.72
    , 1473.62
    , 1479.53
    , 1485.43
    , 1491.33
    , 1497.24
    , 1503.14
    , 1509.04
    , 1514.95
    , 1520.85
    , 1526.75
    , 1532.66
    , 1538.56
    , 1544.46
    , 1550.37
    , 1556.27
    , 1562.17
    , 1568.08
    , 1573.98
    , 1579.88
    , 1585.79
    , 1591.69
    , 1597.59
    , 1603.5
    , 1609.4
    , 1615.31
    , 1621.21
    , 1627.11
    , 1633.02
    , 1638.92
    , 1644.82
    , 1650.73
    , 1656.63
    , 1662.53
    , 1668.44
    , 1674.34
    , 1680.24
    , 1686.15
    , 1692.05
    , 1697.95
    , 1703.86
    , 1709.76
    , 1715.66
    , 1721.57
    , 1727.47
    , 1733.37
    , 1739.28
    , 1745.18
    , 1751.08
    , 1756.99
    , 1762.89
    , 1768.79
    , 1774.7
    , 1780.6
    , 1786.5
    , 1792.41
    , 1798.31
    , 1804.21
    , 1810.12
    , 1816.02
    , 1821.92
    , 1827.83
    , 1833.73
    , 1839.63
    , 1845.54
    , 1851.44
    , 1857.34
    , 1863.25
    , 1869.15
    , 1875.06
    , 1880.96
    , 1886.86
    , 1892.77
    , 1898.67
    , 1904.57
    , 1910.48
    , 1916.38
    , 1922.28
    , 1928.19
    , 1934.09
    , 1939.99
    , 1945.9
    , 1951.8
    , 1957.7
    , 1963.61
    , 1969.51
    , 1975.41
    , 1981.32
    , 1987.22
    , 1993.12
    , 1999.03
    , 2004.93
    , 2010.83
    , 2016.74
    , 2022.64
    , 2028.54
    , 2034.45
    , 2040.35
    , 2046.25
    , 2052.16
    , 2058.06
    , 2063.96
    , 2069.87
    , 2075.77
    , 2081.67
    , 2087.58
    , 2093.48
    , 2099.38
    , 2105.29
    , 2111.19
    , 2117.09
    , 2123
    , 2128.9
    , 2134.81
    , 2140.71
    , 2146.61
    , 2152.52
    , 2158.42
    , 2164.32
    , 2170.23
    , 2176.13
    , 2182.03
    , 2187.94
    , 2193.84
    , 2199.74
    , 2205.65
    , 2211.55
    , 2217.45
    , 2223.36
    , 2229.26
    , 2235.16
    , 2241.07
    , 2246.97
    , 2252.87
    , 2258.78
    , 2264.68
    , 2270.58
    , 2276.49
    , 2282.39
    , 2288.29
    , 2294.2
    , 2300.1
    , 2306
    , 2311.91
    , 2317.81
    , 2323.71
    , 2329.62
    , 2335.52
    , 2341.42
    , 2347.33
    , 2353.23
    , 2359.13
    , 2365.04
    , 2370.94
    , 2376.84
    , 2382.75
    , 2388.65
    , 2394.56
    , 2400.46
    , 2406.36
    , 2412.27
    , 2418.17
    , 2424.07
    , 2429.98
    , 2435.88
    , 2441.78
    , 2447.69
    , 2453.59
    , 2459.49
    , 2465.4
    , 2471.3
    , 2477.2
    , 2483.11
    , 2489.01
    , 2494.91
    , 2500.82
]

dai_dict = dict({
    'Z': {
        'dai_offset': 9,
        1: {
            1: -1, 2: -1, 3: -1,
            4: 9, 5: 9, 6: 9, 7: 9, 8: 9,
            9: 14, 10: 14, 11: 14, 12: 14, 13: 14,
            14: 19, 15: 19, 16: 19, 17: 19, 18: 19,
        },
    },
    'G': {
        # TODO
    }
})

blacklist = ['4,Z5,3,1,2', '4,Z9,2,0,1', '4,Z9,2,0,2', '4,Z9,3,1,1', '4,Z10,1,0,0', '4,Z10,1,0,1', '4,Z10,1,0,2',
             '4,Z10,1,1,0', '4,Z10,1,1,1', '4,Z10,1,1,2', '4,Z10,2,0,0', '4,Z10,2,0,1', '4,Z10,2,0,2', '4,Z10,2,1,0',
             '4,Z10,2,1,1', '4,Z10,2,1,2', '4,Z12,2,0,0', '4,Z12,2,0,1', '4,Z12,2,0,2', '4,Z12,2,1,0', '4,Z12,2,1,1',
             '4,Z12,2,1,2', '4,Z12,3,0,1', '4,Z12,3,1,1', '4,Z12,4,0,1', '4,Z12,4,1,0', '4,Z13,1,0,0', '4,Z13,2,0,1',
             '4,Z13,3,0,2', '4,Z13,4,0,0', '4,Z13,4,0,1', '4,Z13,4,0,2', '4,Z13,4,1,0', '4,Z13,4,1,1', '4,Z13,4,1,2',
             '4,Z13,5,0,0', '4,Z14,3,1,2', '4,Z17,5,0,2']

sample_wavelength_healthy = [
    0.10026231, 0.05851733, 0.07484066, 0.05938412, 0.06616816, 0.06747708
    , 0.07031556, 0.05172355, 0.0417323, 0.04581948, 0.03668714, 0.04598947
    , 0.05760417, 0.03457678, 0.04530298, 0.03947611, 0.04053183, 0.03585113
    , 0.04520662, 0.04269639, 0.03650355, 0.04458528, 0.0384916, 0.04302575
    , 0.03958159, 0.04323683, 0.0406698, 0.0367306, 0.03519563, 0.03698405
    , 0.03671371, 0.03546409, 0.04005995, 0.04268045, 0.04102372, 0.03887427
    , 0.04473017, 0.04349094, 0.04101748, 0.03884202, 0.04154786, 0.04254338
    , 0.04280128, 0.0402889, 0.04231104, 0.04473765, 0.043246, 0.04621982
    , 0.04330388, 0.04405158, 0.04068752, 0.04166959, 0.04396002, 0.0428769
    , 0.04534825, 0.04415571, 0.04296918, 0.04375806, 0.04982871, 0.04960296
    , 0.05369562, 0.05622188, 0.05902746, 0.06315746, 0.06663119, 0.07410783
    , 0.08749443, 0.09250262, 0.09876453, 0.11059313, 0.11764386, 0.13198839
    , 0.14301553, 0.15163842, 0.15396355, 0.1617205, 0.16142093, 0.16855659
    , 0.17408052, 0.17701116, 0.18110147, 0.18037002, 0.17848893, 0.19239499
    , 0.17796159, 0.18195532, 0.17991003, 0.19188748, 0.18367577, 0.18612193
    , 0.18314849, 0.17433548, 0.16829893, 0.16656516, 0.16425857, 0.15712763
    , 0.14881024, 0.14523561, 0.14024588, 0.13453211, 0.12754777, 0.12447561
    , 0.12206717, 0.12366664, 0.11917921, 0.11296253, 0.11236046, 0.10890812
    , 0.11329541, 0.10929575, 0.10867711, 0.10772919, 0.10688181, 0.10187618
    , 0.10215223, 0.09772405, 0.09706027, 0.09645269, 0.09390611, 0.09055293
    , 0.08946928, 0.08354402, 0.08218377, 0.0806835, 0.08179677, 0.08027028
    , 0.07900608, 0.0808944, 0.07973655, 0.07874627, 0.07765871, 0.07262922
    , 0.07017156, 0.06806827, 0.06232353, 0.06211615, 0.05711158, 0.05504495
    , 0.05468151, 0.0538789, 0.05029788, 0.04896448, 0.04981565, 0.04706231
    , 0.04299137, 0.04061964, 0.03954192, 0.04003637, 0.03708427, 0.0364884
    , 0.03746855, 0.03640149, 0.04085382, 0.04034198, 0.04087745, 0.04442775
    , 0.05077203, 0.05708516, 0.06664201, 0.08218747, 0.10076102, 0.1245368
    , 0.14129418, 0.17591594, 0.19711943, 0.22512308, 0.24897635, 0.27677047
    , 0.2983994, 0.32332417, 0.34736127, 0.37536094, 0.391354, 0.41506967
    , 0.4293667, 0.45062295, 0.463784, 0.47686112, 0.48672837, 0.506317
    , 0.5156955, 0.5274842, 0.53691775, 0.54147625, 0.5459926, 0.55057377
    , 0.5577564, 0.5585974, 0.5589313, 0.55803275, 0.5646746, 0.56775635
    , 0.56924015, 0.55894566, 0.56523365, 0.56542534, 0.5615275, 0.5653843
    , 0.56233484, 0.5777618, 0.57138425, 0.55924517, 0.5646773, 0.55961245
    , 0.5688384, 0.57092166, 0.56136405, 0.5619583, 0.56447446, 0.56053364
    , 0.5655595, 0.5584424, 0.5650597, 0.5674819, 0.5670589, 0.55400175
    , 0.56885135, 0.5511187, 0.5580696, 0.56718534, 0.5531843, 0.5672047
    , 0.55614436, 0.5614168, 0.563598, 0.56895983, 0.5591582, 0.55721337
    , 0.55578685, 0.54448247, 0.56694067, 0.54873854, 0.55859905, 0.55718976
    , 0.559094, 0.55157053, 0.5652036, 0.55455875, 0.5537781, 0.5493899
    , 0.55605596, 0.5596772, 0.5467486, 0.5617661, 0.5552509, 0.5476696
    , 0.5589857, 0.5614411, 0.5548585, 0.5524843, 0.5467193, 0.54939514
    , 0.54843533, 0.5521272, 0.5505836, 0.5396709, 0.54357547, 0.5440634
    , 0.5528742, 0.5590725, 0.553799, 0.5448859, 0.5470318, 0.5593481
    , 0.5440516, 0.5596268, 0.5403989, 0.55656254, 0.54894406, 0.528548
    , 0.54887533, 0.5450559, 0.5397317, 0.53874576, 0.5434368, 0.53445846
    , 0.5487129, 0.53868955, 0.5381946, 0.54484576, 0.53208584, 0.5411853
    , 0.5380137, 0.5479277, 0.54606426, 0.5234102, 0.5169213, 0.53361547
    , 0.5221006, 0.5255706, 0.5117049, 0.50495446, 0.5178593, 0.51284444
    , 0.5112657, 0.4781542, 0.4872488, 0.48993194, 0.48627648, 0.49323288
    , 0.48207003, 0.46939814, 0.47400922, 0.47667485, 0.46505603, 0.48431388
    , 0.48647335, 0.49126756, 0.47526506, 0.46705317, 0.4799444, 0.4594795
    , 0.47824705, 0.48983592, 0.46087176, 0.48254502, 0.46447784, 0.4667446
    , 0.5037904, 0.4938938, 0.4759623, 0.51994646, 0.4535532, 0.48767537
    , 0.49378532, 0.4752467, 0.50499016, 0.46910608]

sample_wavelength_diseased = [
    0.09268793, 0.0840362, 0.07835947, 0.07145099, 0.05687676, 0.06732777
    , 0.08883866, 0.08481675, 0.07728953, 0.07897355, 0.06188638, 0.07231282
    , 0.08509123, 0.07450698, 0.07924916, 0.0803307, 0.07763289, 0.08214338
    , 0.08402592, 0.08249939, 0.07864541, 0.07889348, 0.08228002, 0.08504989
    , 0.09460743, 0.08639245, 0.09297607, 0.09151857, 0.09538401, 0.08808248
    , 0.09283606, 0.08926465, 0.09201506, 0.09770207, 0.09262842, 0.09609369
    , 0.10176259, 0.09772544, 0.10002408, 0.09854412, 0.0984687, 0.09755917
    , 0.1023637, 0.09904712, 0.10139021, 0.10430267, 0.10349514, 0.10278621
    , 0.10356464, 0.10703541, 0.10339274, 0.1099354, 0.10448748, 0.11099205
    , 0.11118029, 0.10581271, 0.10958638, 0.1197745, 0.11595715, 0.11741656
    , 0.119572, 0.12009232, 0.12113857, 0.12337349, 0.12131089, 0.12063664
    , 0.12375866, 0.12754753, 0.129949, 0.12572949, 0.126131, 0.13162571
    , 0.13099024, 0.1302871, 0.13310906, 0.13046302, 0.13747424, 0.13470045
    , 0.13081008, 0.13891567, 0.13404793, 0.139466, 0.13689034, 0.13654505
    , 0.13973469, 0.13575652, 0.13535373, 0.13629436, 0.14261872, 0.13728608
    , 0.14100681, 0.13539924, 0.13543265, 0.13571967, 0.13622998, 0.13722384
    , 0.13966948, 0.1354125, 0.13974312, 0.13760363, 0.13787739, 0.13563398
    , 0.13478313, 0.13835359, 0.13136376, 0.13507366, 0.13831255, 0.13662808
    , 0.13715936, 0.13820295, 0.13409398, 0.13471992, 0.13944386, 0.137973
    , 0.13699894, 0.13576871, 0.13296962, 0.13884352, 0.13828555, 0.13227236
    , 0.13629271, 0.13704462, 0.13736773, 0.13799869, 0.14065011, 0.13756807
    , 0.13995999, 0.13915788, 0.14066572, 0.13593157, 0.13918099, 0.14095499
    , 0.1382682, 0.13886088, 0.13932544, 0.14148343, 0.14029242, 0.14467005
    , 0.1421801, 0.14216688, 0.14169927, 0.14002429, 0.14043403, 0.14143337
    , 0.14058302, 0.1426442, 0.1436338, 0.1413227, 0.13757098, 0.14680737
    , 0.14321166, 0.14251527, 0.14601524, 0.14951113, 0.14992617, 0.15412182
    , 0.15480195, 0.15878978, 0.1617617, 0.16969223, 0.16875738, 0.179409
    , 0.17753704, 0.18950905, 0.19252521, 0.19437204, 0.19570428, 0.20144297
    , 0.2028984, 0.20733957, 0.2111602, 0.21532749, 0.21239398, 0.22216728
    , 0.22273071, 0.22849481, 0.2290488, 0.22984567, 0.23025028, 0.23682326
    , 0.24059238, 0.24349503, 0.24573965, 0.24446218, 0.24436483, 0.24793088
    , 0.24425624, 0.24722217, 0.25223744, 0.2566778, 0.25921574, 0.25339308
    , 0.26129723, 0.26505396, 0.25984535, 0.26148596, 0.26876083, 0.26581264
    , 0.2637354, 0.26829296, 0.27218866, 0.26846424, 0.27351648, 0.27947086
    , 0.27539182, 0.27254146, 0.28138492, 0.283291, 0.27374718, 0.2812146
    , 0.2799624, 0.2819122, 0.2936364, 0.28890282, 0.287629, 0.2840777
    , 0.28648353, 0.29451263, 0.2923319, 0.29738715, 0.29006144, 0.30022806
    , 0.29402798, 0.29668373, 0.2976467, 0.30575207, 0.29986683, 0.3054011
    , 0.30550936, 0.30349496, 0.30942824, 0.30509362, 0.3130352, 0.30856654
    , 0.30727792, 0.31293297, 0.3158192, 0.3181271, 0.32005692, 0.3268116
    , 0.3195278, 0.3275892, 0.32473674, 0.32110146, 0.32973018, 0.32090005
    , 0.33390477, 0.32615164, 0.31895062, 0.326376, 0.32501233, 0.3353217
    , 0.32793605, 0.3408215, 0.32963893, 0.3343801, 0.33948296, 0.3336652
    , 0.34937012, 0.33478832, 0.3421309, 0.35150483, 0.3439806, 0.34722993
    , 0.3392972, 0.3492996, 0.35115555, 0.35498056, 0.36322802, 0.3524097
    , 0.35197774, 0.35994563, 0.3562792, 0.35809115, 0.35058787, 0.36024067
    , 0.3536087, 0.370265, 0.369528, 0.3552425, 0.3620711, 0.37438604
    , 0.3738305, 0.36130002, 0.35308787, 0.3698601, 0.36299607, 0.36827856
    , 0.36110866, 0.3643116, 0.38571084, 0.37723622, 0.36179653, 0.3661242
    , 0.36803547, 0.36986065, 0.37162676, 0.37675744, 0.37358886, 0.3709035
    , 0.3692503, 0.3553274, 0.3612218, 0.38936546, 0.38109627, 0.39829057
    , 0.36929977, 0.37546808, 0.3594851, 0.37614977, 0.36105, 0.37254637
    , 0.36556536, 0.38434845, 0.38019517, 0.3665208, 0.37673354, 0.3791998
    , 0.3791969, 0.4039196, 0.38226843, 0.4006649, 0.37997353, 0.3804863
    , 0.39889422, 0.39731693, 0.3814838, 0.373413]
sample_wavelength_healthy_fluid = [0.06042244, 0.06371193, 0.06280197, 0.06844941, 0.04442696, 0.04866322
    , 0.05276875, 0.03914304, 0.03748722, 0.05563917, 0.04549395, 0.05488838
    , 0.0547126, 0.04978333, 0.05681183, 0.05269593, 0.04887924, 0.05819972
    , 0.05309525, 0.05105774, 0.05357864, 0.05520295, 0.05536496, 0.06115755
    , 0.05186166, 0.05635191, 0.05831045, 0.06263021, 0.05802649, 0.06082587
    , 0.06208319, 0.05674451, 0.05719226, 0.06015627, 0.0621319, 0.05985369
    , 0.06305346, 0.06344283, 0.06342207, 0.0610563, 0.06078169, 0.06359648
    , 0.06382408, 0.06173062, 0.06293092, 0.0652592, 0.06090926, 0.06405278
    , 0.06841713, 0.06700501, 0.06745926, 0.0696919, 0.06589384, 0.06814491
    , 0.07107425, 0.06644697, 0.06796546, 0.06891765, 0.070352, 0.0696543
    , 0.07232746, 0.07272201, 0.07241206, 0.07238884, 0.07138363, 0.07144368
    , 0.07229123, 0.0705176, 0.07270767, 0.07849741, 0.07733218, 0.07672554
    , 0.07083665, 0.07969137, 0.07315595, 0.08017026, 0.07776505, 0.07725312
    , 0.0787438, 0.07763309, 0.07994697, 0.08403087, 0.08021187, 0.07901567
    , 0.08070718, 0.07554151, 0.07946938, 0.08196048, 0.07950235, 0.0850509
    , 0.08038411, 0.07838349, 0.08186184, 0.07840467, 0.08045526, 0.08060041
    , 0.07828136, 0.0763104, 0.07902515, 0.07445037, 0.07548008, 0.07847485
    , 0.07411275, 0.07646642, 0.07969506, 0.07728125, 0.07711298, 0.07708741
    , 0.07577844, 0.07593226, 0.0774048, 0.07618711, 0.07748058, 0.07379681
    , 0.07660595, 0.07543164, 0.07583959, 0.07690641, 0.07665878, 0.07532858
    , 0.07709967, 0.07602349, 0.07606169, 0.07550695, 0.07631531, 0.07385943
    , 0.07596056, 0.07581748, 0.07576048, 0.06983442, 0.07489188, 0.07070473
    , 0.07415391, 0.07455896, 0.0746918, 0.07407527, 0.07249793, 0.07551124
    , 0.07295499, 0.07178264, 0.07236665, 0.07225625, 0.07212566, 0.07016671
    , 0.06996337, 0.07033308, 0.07169661, 0.0690238, 0.07108362, 0.06797039
    , 0.06859931, 0.06980753, 0.0703885, 0.06455354, 0.06997932, 0.06863248
    , 0.06738289, 0.06978986, 0.06908849, 0.07159957, 0.07226487, 0.07188251
    , 0.07264049, 0.07439817, 0.0739929, 0.07371349, 0.07568793, 0.07662715
    , 0.07665315, 0.07731602, 0.08123926, 0.07598381, 0.07890519, 0.07836461
    , 0.08230554, 0.07858127, 0.0798507, 0.08059737, 0.07979538, 0.07969653
    , 0.08082843, 0.07762145, 0.0790777, 0.08028822, 0.07907484, 0.07816225
    , 0.07771898, 0.07697128, 0.07745997, 0.08080381, 0.07921726, 0.07848833
    , 0.07395609, 0.08082864, 0.07682304, 0.07493091, 0.0754416, 0.07570194
    , 0.07637152, 0.07449505, 0.07884201, 0.07513081, 0.07181305, 0.07572756
    , 0.0755185, 0.07313576, 0.07623081, 0.07687071, 0.07292477, 0.07618524
    , 0.07556255, 0.07599092, 0.07331434, 0.07360461, 0.07360552, 0.07358716
    , 0.07347826, 0.07493103, 0.07309966, 0.0732798, 0.0692532, 0.07392064
    , 0.06825472, 0.07103005, 0.07362743, 0.06895287, 0.07101416, 0.07394306
    , 0.07019699, 0.06983148, 0.06701653, 0.06800241, 0.06720791, 0.06639582
    , 0.06971657, 0.06849865, 0.06748661, 0.06654232, 0.06448482, 0.06558336
    , 0.06511303, 0.06164254, 0.06575208, 0.06452265, 0.06788127, 0.06352595
    , 0.06196187, 0.06274373, 0.05951433, 0.06303842, 0.06014537, 0.06250124
    , 0.05978817, 0.05678568, 0.0576503, 0.05758934, 0.05869945, 0.05763411
    , 0.05547695, 0.05804758, 0.05568003, 0.06501298, 0.05959579, 0.05671433
    , 0.05632976, 0.06036142, 0.05518613, 0.05788528, 0.05855632, 0.05872886
    , 0.0569409, 0.05785444, 0.05917311, 0.05828126, 0.05936214, 0.05631669
    , 0.05570108, 0.06136648, 0.05257081, 0.05549788, 0.05284349, 0.04871074
    , 0.05275387, 0.04870859, 0.04906745, 0.0451461, 0.0478682, 0.04319729
    , 0.04607814, 0.04253498, 0.0433051, 0.04131465, 0.04130845, 0.0412613
    , 0.03603109, 0.03425575, 0.03202655, 0.03454723, 0.03307824, 0.02542618
    , 0.03588353, 0.02629593, 0.03327975, 0.02729364, 0.02959851, 0.03561861
    , 0.02990561, 0.03336743, 0.02801798, 0.03702448, 0.03796608, 0.03435142
    , 0.03187918, 0.03808369, 0.03021076, 0.02789702, 0.03697495, 0.03771279
    , 0.03051158, 0.0408364, 0.0325933, 0.03955327, 0.03704662, 0.03802525
    , 0.04725802, 0.04355242, 0.0460571, 0.04590889]

sample_wavelength_diseased_fluid = [0.11028031, 0.10128, 0.11887281, 0.09912251, 0.09987445, 0.10975007
    , 0.10725799, 0.10577708, 0.08782768, 0.10089634, 0.10552917, 0.09091917
    , 0.10685249, 0.09986719, 0.09975993, 0.0973442, 0.11440653, 0.10621034
    , 0.11276048, 0.11084028, 0.09966613, 0.09911305, 0.10720608, 0.10168474
    , 0.11537693, 0.11316166, 0.10370833, 0.10952792, 0.11084033, 0.1122876
    , 0.11154118, 0.1132164, 0.12173903, 0.11257644, 0.1100494, 0.11233664
    , 0.11166648, 0.11212958, 0.10916026, 0.10955189, 0.11874083, 0.11541549
    , 0.10516559, 0.11259997, 0.11533727, 0.11206026, 0.1118656, 0.11690368
    , 0.11636829, 0.10851304, 0.11137543, 0.11360357, 0.11083118, 0.11509818
    , 0.10913719, 0.11035759, 0.11263496, 0.11579722, 0.11336769, 0.10769947
    , 0.10807395, 0.11206431, 0.10873622, 0.11380963, 0.10616057, 0.11731081
    , 0.10725005, 0.1097177, 0.1108771, 0.10876409, 0.10951012, 0.10999577
    , 0.10461462, 0.10793483, 0.11081905, 0.10669709, 0.10838477, 0.10873545
    , 0.11057066, 0.10718355, 0.10794882, 0.10538175, 0.10863964, 0.11036805
    , 0.10925081, 0.10234673, 0.10588177, 0.1074168, 0.10758191, 0.10341863
    , 0.10723104, 0.10726307, 0.10698, 0.10580501, 0.10333529, 0.10252503
    , 0.1008632, 0.10163439, 0.10401171, 0.10140422, 0.10295273, 0.09730177
    , 0.09897363, 0.10432441, 0.10053187, 0.10056224, 0.09681301, 0.09888033
    , 0.09914015, 0.09729121, 0.09732131, 0.09601654, 0.09574472, 0.0966756
    , 0.0934093, 0.09341607, 0.09638047, 0.09330285, 0.09255547, 0.0944093
    , 0.09382986, 0.09346163, 0.08888137, 0.08836413, 0.09217244, 0.0902679
    , 0.0909375, 0.08796243, 0.08676765, 0.09102764, 0.09043398, 0.08957169
    , 0.08953831, 0.09064052, 0.08724451, 0.08851206, 0.08691997, 0.08870021
    , 0.08837223, 0.08564558, 0.08760508, 0.08605359, 0.08423028, 0.08534122
    , 0.084617, 0.08438561, 0.08368308, 0.08628912, 0.08361729, 0.08357238
    , 0.08682195, 0.08277505, 0.08190191, 0.08418615, 0.08162375, 0.08236858
    , 0.08045217, 0.08328843, 0.08169812, 0.08026343, 0.08378957, 0.08237884
    , 0.0811268, 0.08471914, 0.08206734, 0.08307761, 0.08395255, 0.08461363
    , 0.08262681, 0.08294396, 0.08294939, 0.08280025, 0.08314674, 0.08477504
    , 0.08319412, 0.08142433, 0.08022272, 0.08080905, 0.08182015, 0.08059623
    , 0.08381808, 0.08066334, 0.08056197, 0.07809243, 0.08102559, 0.07846659
    , 0.07875872, 0.07919004, 0.07816539, 0.07690416, 0.08115312, 0.07646437
    , 0.07890709, 0.08253788, 0.07982608, 0.07667641, 0.07698966, 0.07738665
    , 0.07741527, 0.07623899, 0.07447925, 0.07606262, 0.07601453, 0.07409855
    , 0.07552429, 0.07354547, 0.07218383, 0.07481688, 0.07051404, 0.07209241
    , 0.07619913, 0.07536188, 0.07919338, 0.07450021, 0.07467995, 0.07186749
    , 0.07111744, 0.06880412, 0.07064463, 0.07273106, 0.07120027, 0.07059757
    , 0.06960351, 0.07232042, 0.07183846, 0.06843773, 0.07074095, 0.06958599
    , 0.06814136, 0.07275222, 0.07216229, 0.06840634, 0.06915432, 0.06477373
    , 0.0629428, 0.06666449, 0.06453234, 0.06373825, 0.06227054, 0.06303108
    , 0.06446257, 0.06446116, 0.06508418, 0.06504674, 0.06287943, 0.06160631
    , 0.06483398, 0.06322101, 0.06271479, 0.06265385, 0.06195034, 0.06108718
    , 0.05840127, 0.05695852, 0.05646837, 0.05277379, 0.05865362, 0.05596913
    , 0.0587983, 0.05276254, 0.05681665, 0.05665812, 0.06003195, 0.05613617
    , 0.05903611, 0.05897104, 0.05745584, 0.05928605, 0.05857536, 0.05652115
    , 0.05630061, 0.05614199, 0.05523697, 0.05603461, 0.05435919, 0.05193133
    , 0.05446346, 0.05336318, 0.05377731, 0.05228002, 0.05066851, 0.04876803
    , 0.05330259, 0.0493141, 0.04749919, 0.05514519, 0.04507652, 0.0433779
    , 0.04407945, 0.04595, 0.0419425, 0.04481837, 0.03996555, 0.03875167
    , 0.03272115, 0.03882308, 0.03318021, 0.03593635, 0.02687837, 0.03514256
    , 0.03369183, 0.03105817, 0.03188565, 0.03366737, 0.03007595, 0.0354662
    , 0.02902756, 0.02924959, 0.03279141, 0.03437559, 0.02703535, 0.04284018
    , 0.03119035, 0.0329791, 0.03335661, 0.03949123, 0.03755538, 0.03356882
    , 0.03382472, 0.03710718, 0.0347573, 0.04032156, 0.03744687, 0.04580828
    , 0.05352667, 0.04421608, 0.04091676, 0.04648556]

for dai in range(2, 6):
    dai_dict['Z'][dai] = dai_dict['Z'][1].copy()
    for i in dai_dict['Z'][dai].keys():
        if type(i) == int and i >= 4:
            dai_dict['Z'][dai][i] = dai_dict['Z'][dai][i] + dai - 1


def get_dai_label(sample_id):
    sample_id = sample_id.split(",")
    # sample_id e.g. '1,Z12,...'
    day = sample_id[0]
    plant_type = sample_id[1][0]
    sample_num = sample_id[1][1:]
    label = dai_dict[plant_type][int(day)][int(sample_num)]
    res = 0 if label == -1 else label + 1 - dai_dict[plant_type]['dai_offset']
    return res


def remove_keymap_conflicts(new_keys_set):
    for prop in plt.rcParams:
        if prop.startswith('keymap.'):
            keys = plt.rcParams[prop]
            remove_list = set(keys) & new_keys_set
            for key in remove_list:
                keys.remove(key)


def process_key(event):
    fig = event.canvas.figure
    ax = fig.axes[0]
    if event.key == 'j':
        previous_slice(ax)
    elif event.key == 'k':
        next_slice(ax)
    fig.canvas.draw()


def previous_slice(ax):
    volume = ax.volume
    ax.index = (ax.index - 1) % volume.shape[0]  # wrap around using %
    ax.images[0].set_array(volume[ax.index])
    ax.set_title("Index: {}".format(str(ax.index)))


def next_slice(ax):
    volume = ax.volume
    ax.index = (ax.index + 1) % volume.shape[0]
    ax.images[0].set_array(volume[ax.index])
    ax.set_title("Index: {}".format(str(ax.index)))


class LeafDataset(Dataset):
    def __init__(self, data_path, mode='train',
                 patch_length=3, patch=False, single_image=False,
                 preload_center_crop=0,
                 use_labels=None, use_files=None,
                 balanced=False, split=-1, n_shots=-1, clip=True, use_negative=0, binary_dai=False, fiveD=False,
                 step_wavelength=1, clip_wavelength=400, mask_background=0, cv_n_splits=1,
                 rgb=False):
        ###
        # datapath : root path of memmap files
        # mode : train, eval or test
        # patch_length : if patch is True then this is the radius of an patch
        # single_image : if True then dont iterate over pixels of the image. Instead use one image just once
        # preload_crop : crop image on loading the data. ignored on single image, use patch_length instead
        # use_labels: array of int which defines samples to use by the given labels
        # use_files: array of int which defines files (ids: e.g. Z(1-18)) which are used
        # balance: balance datasets with respect to the labels
        # n_shots: number of leaf per file (one file contains 36 samples)

        # zuckerruebe: not inoculated samples and inoculated samples with dai 9-23 | labels: 0 for not inoculated
        # 1-14 for dai 9-23
        ###
        assert patch_length % 2 != 0
        self.mode = mode
        self.patch_length = patch_length if patch else 0
        self.preload_center_crop = preload_center_crop
        self.single_image = single_image
        self.binary_dai = binary_dai
        self.fiveD = fiveD
        self.mask_background = mask_background
        self.step_wavelength = step_wavelength
        self.clip_wavelength = clip_wavelength
        self.rgb_channels = view_channels_vnir
        self.clip = clip
        self.rgb = rgb
        self.use_negative = use_negative if mode == 'train' else 0
        self.sample_wavelengths = [sample_wavelength_healthy,
                                   sample_wavelength_diseased,
                                   sample_wavelength_healthy_fluid,
                                   sample_wavelength_diseased_fluid]
        self.wavelength_vnir = wavelength_vnir
        self.wavelength_swir = wavelength_swir
        self.memmap_dict, data, self.min_value, self.max_value = self._load_data(data_path,
                                                                                 single_image=single_image,
                                                                                 use_labels=use_labels,
                                                                                 use_files=use_files,
                                                                                 n_shots=n_shots)
        try:
            _, _, _, labels, _ = zip(*data)
        except ValueError:
            raise ValueError("No data available for this configuration.")

        self._load_background_masks(data_path=os.path.join(os.path.dirname(os.path.dirname(data_path)),
                                                           "background_labels_by_spn"))
        labels = np.array(labels)
        # labels_type = np.array([l[0] for l in labels])
        self.num_classes = len(np.unique(labels))
        self.label_mapping = np.unique(labels)
        for i, l in enumerate(labels):
            new_label = (np.where(self.label_mapping == l)[0]).item()
            labels[i] = new_label

        print("Labels:", self.label_mapping)
        print("Num Classes:", self.num_classes)
        if split >= 0:
            train_index, test_index = self.split_data(data, labels, cv_n_splits, split)
        else:
            train_index, test_index = range(len(labels)), range(len(labels))
        if mode == 'train':
            indices = train_index
            if balanced:
                labels_tmp = np.array(labels)[indices]
                class_counts = np.zeros([self.num_classes], dtype=int)
                for c in range(self.num_classes):
                    class_counts[c] = len(labels_tmp[labels_tmp == c])
                min_class_count = np.min(class_counts)

                indices_ = list()
                for c in range(self.num_classes):
                    tmp = indices[labels_tmp == c][:min_class_count].squeeze().tolist()
                    indices_ += tmp

                indices = np.array(indices_, dtype=int)
                # labels_tmp = np.array(labels)[indices_]
                # class_counts = np.zeros([self.num_classes], dtype=int)
                # for c in range(self.num_classes):
                #    class_counts[c] = len(labels_tmp[labels_tmp == c])
        elif mode == 'eval':
            indices = test_index
        elif mode == 'test':
            indices = range(0, len(labels))
        else:
            raise ValueError('wrong mode')

        self.indices = indices
        assert split < 0 or (len(labels) == len(train_index) + len(test_index))
        self.data = [data[i] for i in indices]
        labels_dai = np.array(labels)[indices]
        self.labels = labels_dai
        class_counts = np.zeros([self.num_classes], dtype=int)
        for c in range(self.num_classes):
            class_counts[c] = len(labels_dai[labels_dai == c])

        assert len(labels_dai) == np.sum(class_counts)
        self.class_balance = class_counts / np.sum(class_counts).astype(float)
        if self.binary_dai:
            self.class_balance = torch.Tensor([self.class_balance[0], np.sum(self.class_balance[1:])])
        else:
            self.class_balance = torch.Tensor(self.class_balance)

        self.getsample = self._select_neighboring_patch if patch else self._select_pixel

        self.meta = dict()  # set if used for testing

    def __len__(self):
        return len(self.data)

    def __getitem__(self, idx):
        # sample[idx]: data_path, pos, label
        meta = self.data[idx]
        memmap_id = meta[0]
        sample_idx = meta[1]
        pos = meta[2]
        label_dai = meta[3]
        if self.binary_dai:
            label_dai = 0 if label_dai == 0 else 1
        # print(label_dai)
        sample, label_type, mask = self.getsample(memmap_id, sample_idx, pos[0], pos[1], self.patch_length, meta[4])
        sample = sample.copy()
        sample = self._normalize(sample)

        if self.mask_background == 2:
            res = (sample, mask)
        else:
            res = sample
        return res, (label_dai, label_type, 0, meta), idx

    def split_data(self, data, labels, cv_n_splits, split):
        data_2ndday = [d for d in data if "2,Z" in d[4]]
        labels_2ndday = [d for idx, d in enumerate(labels) if "2,Z" in data[idx][4]]

        sss = StratifiedShuffleSplit(n_splits=cv_n_splits, test_size=0.25, random_state=0)

        splits = [(train, test) for train, test in sss.split(data_2ndday, labels_2ndday)]
        train_index, test_index = splits[split]

        train_index_all, test_index_all = [], []
        train_tmp = []
        for idx_train in train_index:
            leaf_id_along_days = data_2ndday[idx_train][4][2:]
            train_tmp += [leaf_id_along_days]
            selected_ids = [idx for idx in range(len(data)) if leaf_id_along_days in data[idx][4]]
            assert len(selected_ids) <= 5
            train_index_all += selected_ids

        for idx_test in test_index:
            leaf_id_along_days = data_2ndday[idx_test][4][2:]
            selected_ids = [idx for idx in range(len(data)) if leaf_id_along_days in data[idx][4]]
            assert len(selected_ids) <= 5
            test_index_all += selected_ids

        assert len(data) == len(train_index_all) + len(test_index_all)

        return train_index_all, test_index_all

    def getByMeta(self, meta):
        # sample[idx]: data_path, pos, label
        memmap_id = meta[0]
        sample_idx = meta[1]
        pos = meta[2]
        # label = meta[3]
        sample, _, _ = self.getsample(memmap_id, sample_idx, pos[0], pos[1], self.patch_length, None)
        sample = sample.copy()
        sample = self._normalize(sample)
        return sample

    def getMemmapShapeBySample(self, meta):
        memmap_id = meta[0]
        sample_idx = meta[1]
        return self.memmap_dict[memmap_id][0][sample_idx].shape

    def _select_pixel(self, memmap_id, sample_idx, pos_row, pos_col, ex_len, leaf_id):
        pixel = self.memmap_dict[memmap_id][0][sample_idx][pos_row, pos_col, :]
        if self.memmap_dict[memmap_id][1] is not None:
            label = self.memmap_dict[memmap_id][1][sample_idx][pos_row, pos_col]
        else:
            label = -1
        pixel = np.array(pixel)
        label = np.array(label, dtype=np.int64)
        return pixel, label, None

    def _select_neighboring_patch(self, memmap_id, sample_idx, pos_row, pos_col, ex_len, leaf_id):
        if self.single_image:
            if self.patch_length == -1:
                selected_patch = np.array(self.memmap_dict[memmap_id][0][sample_idx][:, :, ::self.step_wavelength])
                selected_patch = selected_patch[:, :, :self.clip_wavelength]
                if self.memmap_dict[memmap_id][1] is not None:
                    selected_labels = self.memmap_dict[memmap_id][1][sample_idx][:, :]
                    selected_labels = np.array(selected_labels, dtype=np.int64)
                else:
                    selected_labels = np.zeros([selected_patch.shape[0], selected_patch.shape[1]], dtype=np.int64)
                    selected_labels[:, :] = -1

                if self.fiveD:
                    if self.mode == 'train':
                        selected_patch = ndimage.rotate(selected_patch, random.randint(0, 359), reshape=False)
                    selected_patch = np.transpose(selected_patch, (2, 0, 1))

                    selected_patch = np.expand_dims(selected_patch, 0)
                else:
                    selected_patch = np.transpose(selected_patch, (2, 0, 1))

                return selected_patch, selected_labels

            ex_len = np.minimum(np.minimum(self.memmap_dict[memmap_id][0][sample_idx].shape[0],
                                           self.memmap_dict[memmap_id][0][sample_idx].shape[1]) // 2, ex_len)
        selected_rows = self.memmap_dict[memmap_id][0][sample_idx][range(pos_row - ex_len, pos_row + ex_len + 1), :,
                        ::self.step_wavelength]
        selected_patch = selected_rows[:, range(pos_col - ex_len, pos_col + ex_len + 1), :self.clip_wavelength]

        if self.memmap_dict[memmap_id][1] is not None:
            selected_rows_labels = self.memmap_dict[memmap_id][1][sample_idx][
                                   range(pos_row - ex_len, pos_row + ex_len + 1), :]
            selected_labels = selected_rows_labels[:, range(pos_col - ex_len, pos_col + ex_len + 1)]
            selected_labels = np.array(selected_labels, dtype=np.int64)
        else:
            selected_labels = np.zeros([selected_patch.shape[0], selected_patch.shape[1]], dtype=np.int64)
            selected_labels[:, :] = -1
        # selected_patch = self.memmap_dict[memmap_id][sample_idx, range(pos_row - ex_len, pos_row + ex_len + 1), range(pos_col - ex_len, pos_col + ex_len + 1)]

        mask = None

        # use mask on training data
        if self.mask_background == 1:
            mask = self.background_masks[leaf_id.replace(",", "_")]
            if selected_patch.shape[0] == 213 and selected_patch.shape[1] == 213:
                selected_patch[mask == 0] = np.zeros([selected_patch.shape[2]], dtype=selected_patch.dtype)
                pass
        elif self.mask_background == 2:
            mask = self.background_masks[leaf_id.replace(",", "_")]
        # plt.imshow(selected_patch[:, :, [10, 30, 50]])
        # plt.show()
        # 1 / 0
        if self.fiveD:
            # rotate
            if self.mode == 'train':
                rot_int = random.randint(0, 359)
                selected_patch = ndimage.rotate(selected_patch, rot_int, reshape=False)
                if self.mask_background == 2:
                    mask = ndimage.rotate(mask, rot_int, reshape=False)
                    mask = (mask * -1) + 1

                    # plt.imshow(selected_patch[:, :, [10, 30, 50]])
                    # plt.figure()
                    # plt.imshow(mask, alpha=1.)
                    # plt.show()
                    # 1 / 0

            # convert to BCHW format
            selected_patch = np.transpose(selected_patch, (2, 0, 1))

            # extend dim
            selected_patch = np.expand_dims(selected_patch, 0)
        else:
            selected_patch = np.transpose(selected_patch, (2, 0, 1))

        return selected_patch, selected_labels, mask

    def _normalize(self, d):
        if self.clip:
            d = np.clip(d, 0., 1.)
        return d

    def _load_background_masks(self,
                               data_path="/media/disk2/datasets/deepplant/data/parsed_data/background_labels_by_spn"):
        import glob
        from skimage.morphology import convex_hull_image, disk, closing, erosion
        import collections

        self.background_masks = dict()
        background_mask_filename = os.path.join(data_path, "preprocessed_masks.pyu")
        if os.path.isfile(background_mask_filename):
            self.background_masks = pickle.load(open(background_mask_filename, "rb"))
            if self.mask_background == 2:
                for key in self.background_masks.keys():
                    mask = self.background_masks[key].astype("float")
                    mask = cv2.resize(mask, (13, 13))
                    self.background_masks[key] = mask.astype("int")
            return
        self.files = sorted(glob.glob(os.path.join(data_path, "*.patrick")))
        for mask_file in tqdm(self.files):
            mask = pickle.load(open(mask_file, "rb"))
            mask = erosion(mask, disk(8))
            mask = closing(mask, disk(10))
            mask = convex_hull_image(mask, tolerance=1e-10)
            mask = erosion(mask, disk(5))
            self.background_masks[os.path.basename(mask_file).replace(".patrick", "")] = mask
            """plt.imshow(mask)
            plt.show()
            plt.clf()
            plt.close()"""
        if not os.path.isfile(background_mask_filename):
            pickle.dump(self.background_masks, open(background_mask_filename, "wb"))

    def _load_data(self, root_path, single_image=False, use_labels=None, use_files=None, n_shots=-1):
        memmap_dict = dict()
        data_list = list()
        min_value_total, max_value_total = 1000000, -1000000

        root_paths = root_path.split(",")
        for root_path in root_paths:
            for root, dirs, files in os.walk(root_path):
                for file in files:
                    if file.endswith('memmap.dat') and not file.endswith('labels_memmap.dat'):
                        path_memmap_file = os.path.join(root)
                        memmap_file, label_mask, data, min_value, max_value, id_data_memmap = self._load_data_single(
                            path_memmap_file,
                            single_image=single_image,
                            use_labels=use_labels,
                            use_files=use_files,
                            n_shots=n_shots)

                        memmap_dict[id_data_memmap] = (memmap_file, label_mask)
                        data_list += data
                        min_value_total = np.minimum(min_value_total, min_value)
                        max_value_total = np.maximum(max_value_total, min_value)
        assert len(memmap_dict.keys()) != 0
        print("Finished loading data")
        return memmap_dict, data_list, min_value_total, max_value_total

    def _load_data_single(self, memmap_path, single_image=False, use_labels=None, use_files=None, n_shots=-1):
        # print("Found HS data in", memmap_path)
        # set id of file
        id_object = time.time()

        data = list()
        # load meta file
        data_dict = pickle.load(open(memmap_path + '/data.p', "rb"))
        # save max and min value for normalization
        min_value = data_dict['min_value']
        max_value = data_dict['max_value']
        memmap_shape = data_dict['memmap_shape']
        memmap_file = np.memmap(memmap_path + '/memmap.dat', dtype='float32', mode='r', shape=memmap_shape)
        label_mask = None

        preload_center_crop = self.preload_center_crop
        # iterate over all images
        samples = data_dict['samples']
        # if isinstance(n_shots, list):
        #    samples = [s for s_idx, s in enumerate(samples) if s_idx in n_shots]
        # elif isinstance(n_shots, int) and n_shots > 0:
        #    samples = samples[:n_shots]

        for sample_idx in range(len(samples)):
            sample = samples[sample_idx]
            if sample['use_to_train'] or self.mode == 'test':
                # open single image
                hs_image = memmap_file[sample['memmap_idx']]
                id_hsi = sample['id']
                label = get_dai_label(id_hsi)
                if id_hsi in blacklist:
                    continue
                id_file = id_hsi.split(",")[1]
                # remove plant type from file id
                id_file = id_file[1:]
                # save max and min value for normalization
                if use_files is None or int(id_file) in use_files:

                    # search for labels of current file
                    id_for_label = id_hsi.split(",")[:2]
                    id_for_label = id_for_label[0] + "_" + id_for_label[1]
                    label_memmap_path = os.path.join(os.path.dirname(os.path.dirname(memmap_path)), 'labels')
                    label_memmap_path = os.path.join(label_memmap_path, id_for_label)

                    # if labels exists add
                    if os.path.isfile(label_memmap_path + '/labels_data.p'):
                        label_dict = pickle.load(open(label_memmap_path + '/labels_data.p', "rb"))
                        label_memmap_shape = label_dict['memmap_shape']
                        label_memmap_file = np.memmap(label_memmap_path + '/labels_memmap.dat',
                                                      dtype='int32',
                                                      mode='r',
                                                      shape=label_memmap_shape)
                        label_mask = label_memmap_file

                    # iterate over pixels of croped image
                    if not single_image:
                        hs_image_shape = hs_image.shape
                        if (isinstance(n_shots, int) and sample_idx < n_shots) or (
                                isinstance(n_shots, list) and sample_idx in n_shots):
                            patch_length = self.patch_length

                            if preload_center_crop != 0:
                                patch_length = (np.minimum(hs_image_shape[0], hs_image_shape[1]) // 2) - (
                                        preload_center_crop // 2)
                                # print(patch_length, hs_image_shape[0], hs_image_shape[1])
                                # 1 / 0
                            for row in range(patch_length, hs_image_shape[0] - patch_length):
                                for col in range(patch_length, hs_image_shape[1] - patch_length):
                                    # print(row, col)
                                    # add sample
                                    if use_labels is None or label in use_labels:
                                        # min_value = np.min(hs_image)
                                        # max_value = np.max(hs_image)
                                        data.append((id_object, sample['memmap_idx'], (row, col), label, id_hsi))
                        # add negative samples
                        if self.use_negative > 1 and label == 14:
                            for row in range(0, hs_image_shape[0] - 0):
                                for col in range(0, hs_image_shape[1] - 0):
                                    # print(row, col)
                                    # add sample
                                    if use_labels is None or label in use_labels:
                                        # TODO fix hack
                                        if label_mask is not None and label_mask[sample_idx, row, col] == 2:
                                            for _ in range(0, self.use_negative):
                                                data.append((id_object, sample['memmap_idx'],
                                                             (row, col), label, id_hsi))
                    else:
                        if (isinstance(n_shots, int) and (sample_idx < n_shots or n_shots < 0)) or (
                                isinstance(n_shots, list) and sample_idx in n_shots):
                            row = hs_image.shape[0] // 2
                            col = hs_image.shape[1] // 2
                            label = get_dai_label(id_hsi)
                            if use_labels is None or label in use_labels:
                                # min_value = np.min(hs_image)
                                data.append((id_object, sample['memmap_idx'], (row, col), label, id_hsi))

        return memmap_file, label_mask, data, min_value, max_value, id_object


def _test_dataset():
    import spectral

    # patch: False -> pixels
    # use_labels: [0] -> healthy leafs
    data_type = "VNIR"
    path = '/media/disk2/datasets/deepplant/data/parsed_data/Z/' + data_type
    # VNIR: patch_length = 105
    # SWIR: patch_length = 37
    # path = '/media/disk2/datasets/deepplant/data/parsed_data/Z/SWIR'
    patch = True
    dataset = LeafDataset(data_path=path, patch_length=213, patch=patch, single_image=True, preload_center_crop=0,
                          use_labels=None, use_files=[14], n_shots=[25, 26, 27, 28, 29, 30, 31, 32, 33, 34],
                          mask_background=0)
    if type == 'SWIR':
        rgb_channels = [24, 51, 118]
    else:
        rgb_channels = [50, 88, 151]
    print("Size train dataset:", len(dataset))
    # plt.show()
    data_loader = DataLoader(dataset, batch_size=1, shuffle=False, num_workers=0)
    print(len(dataset))
    for x, y, _ in data_loader:
        for sample_idx, sample in enumerate(x):
            sample = sample.cpu().detach().numpy()
            sample = np.transpose(sample, (1, 2, 0))
            label = y[1].cpu().detach().numpy().squeeze()
            print(sample.shape)
            print(label.shape)
            # print(y[-1][-2:])
            print('id', y[-1][-1], 'dai:', y[0])
            if patch:
                view = spectral.imshow(sample, bands=rgb_channels, classes=label, title=y[-1][-1])
                # view.set_display_mode('overlay')
                # view.class_alpha = 0.5
                sample_pixel = sample[117, 188, :]
                plt.figure()
                plt.plot(np.arange(0, len(sample_pixel)), sample_pixel)
                plt.show()
                print(sample_pixel)
                input("Press key")
                plt.clf()
                plt.close()
            else:
                plt.plot(np.arange(0, len(sample)), sample)
                plt.show()
            # plt.imshow(sample[:, :, rgb_channels])
            # plt.show()
            # 1 / 0


def mlab_imshowColor(im, alpha=255, **kwargs):
    from mayavi import mlab
    """
    Plot a color image with mayavi.mlab.imshow.
    im is a ndarray with dim (n, m, 3) and scale (0->255]
    alpha is a single number or a ndarray with dim (n*m) and scale (0->255]
    **kwargs is passed onto mayavi.mlab.imshow(..., **kwargs)
    """
    try:
        alpha[0]
    except:
        alpha = pl.ones(im.shape[0] * im.shape[1]) * alpha
    if len(alpha.shape) != 1:
        alpha = alpha.flatten()

    # The lut is a Nx4 array, with the columns representing RGBA
    # (red, green, blue, alpha) coded with integers going from 0 to 255,
    # we create it by stacking all the pixles (r,g,b,alpha) as rows.
    myLut = pl.c_[im.reshape(-1, 3), alpha]
    myLutLookupArray = pl.arange(im.shape[0] * im.shape[1]).reshape(im.shape[0], im.shape[1])

    # We can display an color image by using mlab.imshow, a lut color list and a lut lookup table.
    theImshow = mlab.imshow(myLutLookupArray, colormap='binary', **kwargs)  # temporary colormap
    theImshow.module_manager.scalar_lut_manager.lut.table = myLut
    mlab.draw()

    return theImshow


def _show_cube_with_images(cube, rgb_channels):
    from mayavi import mlab
    from tvtk.api import tvtk

    rgbimage = cube[:, :, rgb_channels]  # np.random.random((213, 213))

    image_wvslice1 = cube[120, :, :]
    image_wvslice2 = cube[:, 120, :]
    image_wvslice1 = np.rot90(image_wvslice1, 1)
    image_wvslice2 = np.rot90(image_wvslice2, 1)

    image = np.random.random((213, 213))
    # image[:,:] = 0
    # im = mlab.imshow(rgbimage,
    #                 extent=[0, 50, 0, 50, 0, 50],
    #                 interpolate=False, opacity=.3)

    colors = tvtk.UnsignedCharArray()
    # rgbimage = np.rot90(rgbimage, 2)
    rgbimage = np.dstack((rgbimage, np.ones((rgbimage.shape[0], rgbimage.shape[1]))))
    colors.from_array(rgbimage.transpose((1, 0, 2)).reshape(-1, 4) * 255)
    im = mlab.imshow(np.ones(rgbimage.shape[:2]), extent=[0, 50, 0, 50, 0, 50],
                     interpolate=False, opacity=1.)
    im.actor.input.point_data.scalars = colors

    # mlab.axes(im)

    im.actor.orientation = [0, 90, 0]
    im.actor.position = [25, 0, 25]

    image2 = np.random.random((213, 328))
    image2[:, :] = 255

    im = mlab.imshow(image_wvslice2, colormap='jet',
                     extent=[0, 50, 0, 50, 0, 50],
                     interpolate=False, opacity=1.)

    im.actor.orientation = [90, 0, 0]
    im.actor.position = [0, 25, 25]

    im = mlab.imshow(image,
                     extent=[0, 50, 0, 50, 0, 50],
                     interpolate=False, opacity=.3)

    im.actor.orientation = [0, 0, 0]
    im.actor.position = [0, 0, 0]

    im = mlab.imshow(image_wvslice1,
                     extent=[0, 50, 0, 50, 0, 50],
                     interpolate=False, opacity=1.)

    im.actor.orientation = [0, 0, 0]
    im.actor.position = [0, 0, 50]

    im = mlab.imshow(image,
                     extent=[0, 50, 0, 50, 0, 50],
                     interpolate=False, opacity=.3)

    im.actor.orientation = [90, 0, 0]
    im.actor.position = [0, -25, 25]

    im = mlab.imshow(image,
                     extent=[0, 50, 0, 50, 0, 50],
                     interpolate=False, opacity=.3)

    im.actor.orientation = [0, 90, 0]
    im.actor.position = [-25, 0, 25]
    # im.actor.scale = [.5, .5, .5]

    mlab.show()
    1 / 0


def _show_cube():
    import scipy.io
    # patch: False -> pixels
    # use_labels: [0] -> healthy leafs
    data_type = "VNIR"
    path = '/media/disk2/datasets/deepplant/data/parsed_data/Z/' + data_type
    # VNIR: patch_length = 105
    # SWIR: patch_length = 37
    # path = '/media/disk2/datasets/deepplant/data/parsed_data/Z/SWIR'
    patch = True
    dataset = LeafDataset(data_path=path, patch_length=213, patch=patch, single_image=True, preload_center_crop=0,
                          use_labels=None, use_files=[8], n_shots=[25], mask_background=0,
                          step_wavelength=5, clip_wavelength=64)
    if type == 'SWIR':
        rgb_channels = [24, 51, 118]
    else:
        rgb_channels = [50, 88, 151]
    print("Size train dataset:", len(dataset))
    # plt.show()
    data_loader = DataLoader(dataset, batch_size=1, shuffle=False, num_workers=0)
    print(len(dataset))
    for x, y, _ in data_loader:
        for sample_idx, sample in enumerate(x):
            sample = sample.cpu().detach().numpy()
            sample = np.transpose(sample, (1, 2, 0))
            label = y[1].cpu().detach().numpy().squeeze()
            print(sample.shape)
            print(label.shape)
            # print(y[-1][-2:])
            print('id', y[-1][-1], 'dai:', y[0])
            if patch:
                # spectral.imshow(sample)
                # input("press key")
                scipy.io.savemat('/media/disk2/datasets/deepplant/data/parsed_data/Z/sample.mat', {'data': sample})
                # _show_cube_with_images(sample, rgb_channels)
            else:
                plt.plot(np.arange(0, len(sample)), sample)
                plt.show()
            # plt.imshow(sample[:, :, rgb_channels])
            # plt.show()
            # 1 / 0

if __name__ == '__main__':
    _show_cube()
